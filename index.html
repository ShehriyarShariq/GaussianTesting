<!DOCTYPE html>
<html>
  <head>
    <title>PLY Point Cloud Viewer with Three.js</title>
    <style>
      body {
        margin: 0;
      }
      canvas {
        display: block;
      }
    </style>
  </head>
  <body>
    <input type="file" id="fileInput" />
    <script src="https://unpkg.com/three@0.127.0/build/three.min.js"></script>
    <!-- Include OrbitControls.js for camera control if needed -->
    <script src="https://unpkg.com/three@0.127.0/examples/js/controls/OrbitControls.js"></script>
    <script>
      const vertexShader = `
      precision highp float;
      precision highp int;

      uniform highp usampler2D u_texture;
      uniform mat4 projection, view;
      uniform vec2 focal;
      uniform vec2 viewport;

      uniform bool u_useDepthFade;
      uniform float u_depthFade;

      in int index;

      out vec4 vColor;
      out vec2 vPosition;

      void main () {
          uvec4 cen = texelFetch(u_texture, ivec2((uint(index) & 0x3ffu) << 1, uint(index) >> 10), 0);
          vec4 cam = view * vec4(uintBitsToFloat(cen.xyz), 1);
          vec4 pos2d = projection * cam;

          float clip = 1.2 * pos2d.w;
          if (pos2d.z < -pos2d.w || pos2d.x < -clip || pos2d.x > clip || pos2d.y < -clip || pos2d.y > clip) {
              gl_Position = vec4(0.0, 0.0, 2.0, 1.0);
              return;
          }


          uvec4 cov = texelFetch(u_texture, ivec2(((uint(index) & 0x3ffu) << 1) | 1u, uint(index) >> 10), 0);
          vec2 u1 = unpackHalf2x16(cov.x), u2 = unpackHalf2x16(cov.y), u3 = unpackHalf2x16(cov.z);
          mat3 Vrk = mat3(u1.x, u1.y, u2.x, u1.y, u2.y, u3.x, u2.x, u3.x, u3.y);

          mat3 J = mat3(
              focal.x / cam.z, 0., -(focal.x * cam.x) / (cam.z * cam.z),
              0., -focal.y / cam.z, (focal.y * cam.y) / (cam.z * cam.z),
              0., 0., 0.
          );

          mat3 T = transpose(mat3(view)) * J;
          mat3 cov2d = transpose(T) * Vrk * T;

          float mid = (cov2d[0][0] + cov2d[1][1]) / 2.0;
          float radius = length(vec2((cov2d[0][0] - cov2d[1][1]) / 2.0, cov2d[0][1]));
          float lambda1 = mid + radius, lambda2 = mid - radius;

          if(lambda2 < 0.0) return;
          vec2 diagonalVector = normalize(vec2(cov2d[0][1], lambda1 - cov2d[0][0]));
          vec2 majorAxis = min(sqrt(2.0 * lambda1), 1024.0) * diagonalVector;
          vec2 minorAxis = min(sqrt(2.0 * lambda2), 1024.0) * vec2(diagonalVector.y, -diagonalVector.x);

          vColor = vec4((cov.w) & 0xffu, (cov.w >> 8) & 0xffu, (cov.w >> 16) & 0xffu, (cov.w >> 24) & 0xffu) / 255.0;
          vPosition = position.xy;

          float scalingFactor = 1.0;

          if(u_useDepthFade) {
              float depthNorm = (pos2d.z / pos2d.w + 1.0) / 2.0;
              float near = 0.1; float far = 100.0;
              float normalizedDepth = (2.0 * near) / (far + near - depthNorm * (far - near));
              float start = max(normalizedDepth - 0.1, 0.0);
              float end = min(normalizedDepth + 0.1, 1.0);
              scalingFactor = clamp((u_depthFade - start) / (end - start), 0.0, 1.0);
          }

          vec2 vCenter = vec2(pos2d) / pos2d.w;
          gl_Position = vec4(
              vCenter
              + position.xy.x * majorAxis * scalingFactor / viewport
              + position.xy.y * minorAxis * scalingFactor / viewport, 0.0, 1.0);
      }
      `

      const fragmentShader = `
      precision highp float;

      uniform highp usampler2D u_texture;

      in vec4 vColor;
      in vec2 vPosition;

      out vec4 fragColor;

      void main () {
          float A = -dot(vPosition, vPosition);
          if (A < -4.0) discard;
          float B = exp(A) * vColor.a;
          fragColor = vec4(B * vColor.rgb, B);
      }
      `

      const RowLength = 3 * 4 + 3 * 4 + 4 + 4

      let scene = new THREE.Scene()
      let camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        1000,
      )

      const canvas = document.createElement('canvas')
      document.body.appendChild(canvas)
      const context = canvas.getContext('webgl2')
      const renderer = new THREE.WebGLRenderer({
        canvas: canvas,
        context: context,
      })
      renderer.getContext().getExtension('EXT_color_buffer_float')
      renderer.setSize(window.innerWidth, window.innerHeight)
      //   document.body.appendChild(renderer.domElement)

      renderer.setClearColor(0x000000)

      let controls = new THREE.OrbitControls(camera, canvas)
      //   let controls = new THREE.OrbitControls(camera, renderer.domElement)
      camera.position.z = 5

      const uniforms = {
        u_texture: { type: 't', value: null }, // You will need to set these textures with your data
        projection: { value: camera.projectionMatrix },
        view: { value: camera.matrixWorldInverse },
        viewport: {
          value: new THREE.Vector2(window.innerWidth, window.innerHeight),
        },
        u_useDepthFade: { value: true },
        u_depthFade: { value: 1.0 },
      }

      // Create ShaderMaterial
      const shaderMaterial = new THREE.ShaderMaterial({
        uniforms: uniforms,
        vertexShader: vertexShader,
        fragmentShader: fragmentShader,
        glslVersion: THREE.GLSL3,
        transparent: true, // if you're using alpha values
        depthWrite: false, // Depending on your needs
        // blending: THREE.AdditiveBlending,
      })

      function calculateTextureSize(data) {
        const sideWidth = 2048

        const sideHeight = Math.ceil(
          (2 * (data.length / RowLength)) / sideWidth,
        )

        return { width: sideWidth, height: sideHeight }
      }

      document
        .getElementById('fileInput')
        .addEventListener('change', function (event) {
          const file = event.target.files[0]
          if (!file) {
            console.log('No file selected.')
            return
          }

          const reader = new FileReader()
          reader.onload = async (e) => {
            const buffer = e.target.result

            const { data, geometry } = parseSplat(new Uint8Array(buffer))

            const { width, height } = calculateTextureSize(
              new Uint8Array(buffer),
            )

            const dataTexture = new THREE.DataTexture(
              data,
              width,
              height,
              THREE.RGBAIntegerFormat,
              THREE.UnsignedIntType,
            )
            dataTexture.internalFormat = 'RGBA32UI'
            dataTexture.needsUpdate = true

            // // Update the shader material with the new texture
            shaderMaterial.uniforms.u_texture.value = dataTexture

            createPointCloud(geometry)
          }
          reader.readAsArrayBuffer(file)
        })

      function parseSplat(data) {
        const { width, height } = calculateTextureSize(data)

        const vertexCount = data.length / RowLength
        const positions = new Float32Array(vertexCount * 3)
        const colors = new Uint8Array(vertexCount * 3)
        const scales = new Float32Array(vertexCount * 3) // If needed
        const rotations = new Float32Array(vertexCount * 4) // If needed
        const indices = new Uint32Array(vertexCount)

        const _floatView = new Float32Array(1)
        const _int32View = new Int32Array(_floatView.buffer)

        const floatToHalf = (float) => {
          _floatView[0] = float
          const f = _int32View[0]

          const sign = (f >> 31) & 0x0001
          const exp = (f >> 23) & 0x00ff
          let frac = f & 0x007fffff

          let newExp
          if (exp == 0) {
            newExp = 0
          } else if (exp < 113) {
            newExp = 0
            frac |= 0x00800000
            frac = frac >> (113 - exp)
            if (frac & 0x01000000) {
              newExp = 1
              frac = 0
            }
          } else if (exp < 142) {
            newExp = exp - 112
          } else {
            newExp = 31
            frac = 0
          }

          return (sign << 15) | (newExp << 10) | (frac >> 13)
        }

        const packHalf2x16 = (x, y) => {
          return (floatToHalf(x) | (floatToHalf(y) << 16)) >>> 0
        }

        const _data = new Uint32Array(width * height * 4)

        const dataView = new DataView(data.buffer)
        const _dataView = new DataView(_data.buffer)

        for (let i = 0; i < vertexCount; i++) {
          // Assuming the structure based on the provided setData function
          const offset = i * RowLength

          if (dataView.getFloat32(8 * i + 0, true) != NaN) {
            positions[3 * i + 0] = dataView.getFloat32(8 * i + 0, true)
          }
          if (dataView.getFloat32(8 * i + 1, true) != NaN) {
            positions[3 * i + 1] = dataView.getFloat32(8 * i + 1, true)
          }
          if (dataView.getFloat32(8 * i + 2, true) != NaN) {
            positions[3 * i + 2] = dataView.getFloat32(8 * i + 2, true)
          }

          // positions[3 * i + 0] = dataView.getFloat32(offset, true)
          // positions[3 * i + 1] = dataView.getFloat32(offset + 4, true)
          // positions[3 * i + 2] = dataView.getFloat32(offset + 8, true)

          rotations[4 * i + 0] =
            (dataView.getUint8(32 * i + 28 + 0) - 128) / 128
          rotations[4 * i + 1] =
            (dataView.getUint8(32 * i + 28 + 1) - 128) / 128
          rotations[4 * i + 2] =
            (dataView.getUint8(32 * i + 28 + 2) - 128) / 128
          rotations[4 * i + 3] =
            (dataView.getUint8(32 * i + 28 + 3) - 128) / 128

          scales[3 * i + 0] = dataView.getFloat32(8 * i + 3 + 0, true)
          scales[3 * i + 1] = dataView.getFloat32(8 * i + 3 + 1, true)
          scales[3 * i + 2] = dataView.getFloat32(8 * i + 3 + 2, true)

          // Assuming color data is stored as bytes immediately after positions
          colors[i * 3] = data[offset + 12]
          colors[i * 3 + 1] = data[offset + 13]
          colors[i * 3 + 2] = data[offset + 14]

          _dataView.setFloat32(8 * i + 0, positions[3 * i + 0], true)
          _dataView.setFloat32(8 * i + 1, positions[3 * i + 1], true)
          _dataView.setFloat32(8 * i + 2, positions[3 * i + 2], true)

          _dataView.setUint8(
            4 * (8 * i + 7) + 0,
            dataView.getUint8(32 * i + 24 + 0),
          )
          _dataView.setUint8(
            4 * (8 * i + 7) + 1,
            dataView.getUint8(32 * i + 24 + 1),
          )
          _dataView.setUint8(
            4 * (8 * i + 7) + 2,
            dataView.getUint8(32 * i + 24 + 2),
          )
          _dataView.setUint8(
            4 * (8 * i + 7) + 3,
            dataView.getUint8(32 * i + 24 + 3),
          )

          const quaternion = new THREE.Quaternion(
            rotations[4 * i + 1],
            rotations[4 * i + 2],
            rotations[4 * i + 3],
            -rotations[4 * i + 0],
          )

          const scale = new THREE.Vector3(
            scales[3 * i + 0],
            scales[3 * i + 1],
            scales[3 * i + 2],
          )

          const matrix = new THREE.Matrix4()
          matrix.compose(
            new THREE.Vector3(0, 0, 0), // Assuming no translation
            quaternion,
            scale,
          )

          // Extract the rotation matrix part for covariance computation
          const M = new THREE.Matrix3().setFromMatrix4(matrix)

          const sigma = [
            M.elements[0] * M.elements[0] +
              M.elements[3] * M.elements[3] +
              M.elements[6] * M.elements[6],
            M.elements[0] * M.elements[1] +
              M.elements[3] * M.elements[4] +
              M.elements[6] * M.elements[7],
            M.elements[0] * M.elements[2] +
              M.elements[3] * M.elements[5] +
              M.elements[6] * M.elements[8],
            M.elements[1] * M.elements[1] +
              M.elements[4] * M.elements[4] +
              M.elements[7] * M.elements[7],
            M.elements[1] * M.elements[2] +
              M.elements[4] * M.elements[5] +
              M.elements[7] * M.elements[8],
            M.elements[2] * M.elements[2] +
              M.elements[5] * M.elements[5] +
              M.elements[8] * M.elements[8],
          ]

          _data[8 * i + 4] = packHalf2x16(4 * sigma[0], 4 * sigma[1])
          _data[8 * i + 5] = packHalf2x16(4 * sigma[2], 4 * sigma[3])
          _data[8 * i + 6] = packHalf2x16(4 * sigma[4], 4 * sigma[5])

          indices[i] = i
        }

        const geometry = new THREE.BufferGeometry()
        geometry.setAttribute(
          'position',
          new THREE.BufferAttribute(positions, 3),
        )

        // geometry.setAttribute(
        //   'aPosition',
        //   new THREE.BufferAttribute(positions, 2),
        // )

        // geometry.setAttribute(
        //   'color',
        //   new THREE.BufferAttribute(colors, 3, true),
        // ) // true for normalized colors

        geometry.setAttribute(
          'index',
          new THREE.InstancedBufferAttribute(indices, 1, false),
        )

        return { data: _data, geometry }
      }

      function createPointCloud(geometry) {
        shaderMaterial.uniforms.projection.value = camera.projectionMatrix
        shaderMaterial.uniforms.view.value = camera.matrixWorldInverse

        const material = new THREE.PointsMaterial({
          size: 0.05,
          vertexColors: true,
        })

        const pointCloud = new THREE.Points(geometry, shaderMaterial)
        // const pointCloud = new THREE.Points(geometry, material)
        scene.add(pointCloud)
      }

      function animate() {
        requestAnimationFrame(animate)

        // Update camera-dependent uniforms
        shaderMaterial.uniforms.projection.value = camera.projectionMatrix
        shaderMaterial.uniforms.view.value = camera.matrixWorldInverse

        controls.update()
        renderer.render(scene, camera)
      }

      animate() // Start the animation loop
    </script>
  </body>
</html>
